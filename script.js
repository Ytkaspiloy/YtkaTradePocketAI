// ==================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ====================
const CONFIG = {
    // –†–µ–∂–∏–º —è–∑—ã–∫–∞
    languages: {
        ru: {
            // –û–±—â–∏–µ
            title: "SCALPING ROBOT PRO",
            subtitle: "–¢–æ—Ä–≥–æ–≤–ª—è –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –æ–ø—Ü–∏–æ–Ω–∞–º–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏",
            demoMode: "–î–µ–º–æ —Ä–µ–∂–∏–º",
            waiting: "–û–∂–∏–¥–∞–Ω–∏–µ",
            
            // –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            instrument: "–ò–ù–°–¢–†–£–ú–ï–ù–¢",
            expiration: "–≠–ö–°–ü–ò–†–ê–¶–ò–Ø",
            signalType: "–¢–ò–ü –°–ò–ì–ù–ê–õ–ê",
            indicators: "–ò–ù–î–ò–ö–ê–¢–û–†–´",
            drawingTools: "–ò–ù–°–¢–†–£–ú–ï–ù–¢–´ –†–ò–°–û–í–ê–ù–ò–Ø",
            signal: "–°–ò–ì–ù–ê–õ",
            
            // –¢–∏–ø—ã —Å–∏–≥–Ω–∞–ª–æ–≤
            smartMoney: "Smart Money",
            combined: "–ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π",
            
            // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
            support: "–ü–æ–¥–¥–µ—Ä–∂–∫–∞",
            resistance: "–°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ",
            
            // –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∏—Å–æ–≤–∞–Ω–∏—è
            line: "–õ–∏–Ω–∏—è",
            horizontal: "–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å",
            clear: "–û—á–∏—Å—Ç–∏—Ç—å",
            
            // –ö–Ω–æ–ø–∫–∏
            getSignal: "–ü–û–õ–£–ß–ò–¢–¨ –°–ò–ì–ù–ê–õ",
            updatingPrices: "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω...",
            
            // –ì—Ä–∞—Ñ–∏–∫
            candles: "–°–≤–µ—á–∏",
            area: "–û–±–ª–∞—Å—Ç—å",
            timeframe: "–¢–∞–π–º—Ñ—Ä–µ–π–º",
            
            // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            currentPrice: "–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞:",
            change: "–ò–∑–º–µ–Ω–µ–Ω–∏–µ:",
            accuracy: "–¢–æ—á–Ω–æ—Å—Ç—å:",
            
            // –°–∏–≥–Ω–∞–ª
            currentSignal: "–¢–ï–ö–£–©–ò–ô –°–ò–ì–ù–ê–õ",
            clickGenerate: "–ù–∞–∂–º–∏—Ç–µ '–ü–æ–ª—É—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª' –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞",
            expiresIn: "–ò—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑:",
            
            // –†–µ–∑—É–ª—å—Ç–∞—Ç—ã
            lastResults: "–ü–û–°–õ–ï–î–ù–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´",
            
            // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            dataSource: "–ò—Å—Ç–æ—á–Ω–∏–∫: Real-time Market Data",
            apiInfo: "–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ä–µ–∞–ª—å–Ω—ã–µ –∫–æ—Ç–∏—Ä–æ–≤–∫–∏ Forex. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥.",
            disclaimer: "–¢–æ—Ä–≥–æ–≤–ª—è –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –æ–ø—Ü–∏–æ–Ω–∞–º–∏ —Å–≤—è–∑–∞–Ω–∞ —Å –≤—ã—Å–æ–∫–∏–º–∏ —Ä–∏—Å–∫–∞–º–∏. Past performance is not indicative of future results.",
            
            // –ê–Ω–∞–ª–∏–∑
            analysis: "–ê–ù–ê–õ–ò–ó",
            rsi: "RSI",
            macd: "MACD",
            ema: "EMA",
            trend: "–¢—Ä–µ–Ω–¥",
            volume: "–û–±—ä–µ–º",
            strength: "–°–∏–ª–∞",
            buy: "–ü–û–ö–£–ü–ö–ê",
            sell: "–ü–†–û–î–ê–ñ–ê",
            win: "–í–´–ò–ì–†–´–®",
            loss: "–ü–†–û–ò–ì–†–´–®",
            refund: "–í–û–ó–í–†–ê–¢",
            entryPrice: "–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞:",
            exitPrice: "–¶–µ–Ω–∞ –≤—ã—Ö–æ–¥–∞:",
            result: "–†–µ–∑—É–ª—å—Ç–∞—Ç:"
        },
        en: {
            // General
            title: "SCALPING ROBOT PRO",
            subtitle: "Real-Time Binary Options Trading",
            demoMode: "Demo Mode",
            waiting: "Waiting",
            
            // Control Panel
            instrument: "INSTRUMENT",
            expiration: "EXPIRATION",
            signalType: "SIGNAL TYPE",
            indicators: "INDICATORS",
            drawingTools: "DRAWING TOOLS",
            signal: "SIGNAL",
            
            // Signal Types
            smartMoney: "Smart Money",
            combined: "Combined",
            
            // Indicators
            support: "Support",
            resistance: "Resistance",
            
            // Drawing Tools
            line: "Line",
            horizontal: "Horizontal",
            clear: "Clear",
            
            // Buttons
            getSignal: "GET SIGNAL",
            updatingPrices: "Updating prices...",
            
            // Chart
            candles: "Candles",
            area: "Area",
            timeframe: "Timeframe",
            
            // Stats
            currentPrice: "Current Price:",
            change: "Change:",
            accuracy: "Accuracy:",
            
            // Signal
            currentSignal: "CURRENT SIGNAL",
            clickGenerate: "Click 'Get Signal' to analyze",
            expiresIn: "Expires in:",
            
            // Results
            lastResults: "LAST RESULTS",
            
            // Info
            dataSource: "Source: Real-time Market Data",
            apiInfo: "Using real Forex quotes. Updates every 5 seconds.",
            disclaimer: "Binary options trading involves high risks. Past performance is not indicative of future results.",
            
            // Analysis
            analysis: "ANALYSIS",
            rsi: "RSI",
            macd: "MACD",
            ema: "EMA",
            trend: "Trend",
            volume: "Volume",
            strength: "Strength",
            buy: "BUY",
            sell: "SELL",
            win: "WIN",
            loss: "LOSS",
            refund: "REFUND",
            entryPrice: "Entry Price:",
            exitPrice: "Exit Price:",
            result: "Result:"
        }
    },
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∞–∫—Ç–∏–≤–æ–≤
    assets: {
        'EURUSD': { 
            name: 'EUR/USD', 
            base: 'EUR',
            quote: 'USD',
            price: 1.0830,
            volatility: 0.0005
        },
        'USDJPY': { 
            name: 'USD/JPY', 
            base: 'USD',
            quote: 'JPY',
            price: 148.35,
            volatility: 0.001
        },
        'GBPUSD': { 
            name: 'GBP/USD', 
            base: 'GBP',
            quote: 'USD',
            price: 1.2650,
            volatility: 0.0008
        },
        'AUDUSD': { 
            name: 'AUD/USD', 
            base: 'AUD',
            quote: 'USD',
            price: 0.6590,
            volatility: 0.0006
        },
        'USDCAD': { 
            name: 'USD/CAD', 
            base: 'USD',
            quote: 'CAD',
            price: 1.3520,
            volatility: 0.0004
        },
        'USDCHF': { 
            name: 'USD/CHF', 
            base: 'USD',
            quote: 'CHF',
            price: 0.9025,
            volatility: 0.0004
        },
        'EURJPY': { 
            name: 'EUR/JPY', 
            base: 'EUR',
            quote: 'JPY',
            price: 160.42,
            volatility: 0.0012
        },
        'GBPJPY': { 
            name: 'GBP/JPY', 
            base: 'GBP',
            quote: 'JPY',
            price: 187.65,
            volatility: 0.0015
        }
    },
    
    // –¢–∞–π–º—Ñ—Ä–µ–π–º—ã
    timeframes: {
        60: "1 –º–∏–Ω",
        120: "2 –º–∏–Ω",
        180: "3 –º–∏–Ω",
        300: "5 –º–∏–Ω"
    }
};

// ==================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ====================
let currentLanguage = 'ru';
let currentChart = null;
let currentSignal = null;
let isSignalActive = false;
let expirationTimer = null;
let priceUpdateInterval = null;
let resultsHistory = [];
let currentAsset = 'EURUSD';
let currentTimeframe = 60;
let chartType = 'candlestick';
let signalType = 'smart';
let drawingMode = null;
let drawnElements = [];
let priceHistory = [];
let indicatorsData = {};

// ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ====================
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Scalping Robot Pro...');
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —è–∑—ã–∫–∞
    initLanguage();
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∏–∫–∞
    initChart();
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏–π
    initEvents();
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—á–∞–ª—å–Ω—ã—Ö —Ü–µ–Ω
    loadInitialPrices();
    
    // –ó–∞–ø—É—Å–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω
    startPriceUpdates();
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏
    loadHistory();
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
    initDrawingTools();
    
    console.log('‚úÖ Scalping Robot Pro –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!');
});

// ==================== –°–ò–°–¢–ï–ú–ê –Ø–ó–´–ö–ê ====================
function initLanguage() {
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —è–∑—ã–∫–∞
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const lang = this.dataset.lang;
            switchLanguage(lang);
        });
    });
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    switchLanguage('ru');
}

function switchLanguage(lang) {
    currentLanguage = lang;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –∫–Ω–æ–ø–∫—É
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.lang === lang) {
            btn.classList.add('active');
        }
    });
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ —Ç–µ–∫—Å—Ç—ã
    applyTranslations();
}

function applyTranslations() {
    const dict = CONFIG.languages[currentLanguage];
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å data-i18n
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (dict[key]) {
            if (element.tagName === 'INPUT') {
                element.placeholder = dict[key];
            } else {
                element.textContent = dict[key];
            }
        }
    });
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É —Å–∏–≥–Ω–∞–ª–∞
    const signalBtn = document.getElementById('generate-signal');
    if (signalBtn) {
        const span = signalBtn.querySelector('span');
        if (span) span.textContent = dict.getSignal;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –µ—Å–ª–∏ –æ–∂–∏–¥–∞–Ω–∏–µ
    const statusText = document.getElementById('status-text');
    if (statusText && !isSignalActive) {
        statusText.textContent = dict.waiting;
    }
}

// ==================== –ì–†–ê–§–ò–ö ====================
function initChart() {
    const ctx = document.getElementById('trading-chart').getContext('2d');
    
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    const data = generateCandlestickData(50);
    
    // –°–æ–∑–¥–∞–µ–º —Å–≤–µ—á–Ω–æ–π –≥—Ä–∞—Ñ–∏–∫
    currentChart = new Chart(ctx, {
        type: 'candlestick',
        data: {
            datasets: [{
                label: CONFIG.assets[currentAsset].name,
                data: data.candles,
                borderColor: ctx => {
                    const candle = data.candles[ctx.dataIndex];
                    return candle.c >= candle.o ? '#00ff88' : '#ff4444';
                },
                backgroundColor: ctx => {
                    const candle = data.candles[ctx.dataIndex];
                    return candle.c >= candle.o ? 'rgba(0, 255, 136, 0.3)' : 'rgba(255, 68, 68, 0.3)';
                },
                borderWidth: 1,
                borderColorUp: '#00ff88',
                borderColorDown: '#ff4444',
                borderColorDoji: '#8b9dc3',
                colorUp: 'rgba(0, 255, 136, 0.8)',
                colorDown: 'rgba(255, 68, 68, 0.8)'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(26, 34, 56, 0.95)',
                    titleColor: '#8b9dc3',
                    bodyColor: '#ffffff',
                    borderColor: '#2a3655',
                    borderWidth: 1,
                    cornerRadius: 8,
                    callbacks: {
                        label: function(context) {
                            const candle = context.raw;
                            return [
                                `Open: ${candle.o.toFixed(5)}`,
                                `High: ${candle.h.toFixed(5)}`,
                                `Low: ${candle.l.toFixed(5)}`,
                                `Close: ${candle.c.toFixed(5)}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'minute',
                        displayFormats: {
                            minute: 'HH:mm'
                        }
                    },
                    grid: {
                        color: 'rgba(42, 54, 85, 0.3)',
                        drawBorder: false
                    },
                    ticks: {
                        color: '#8b9dc3',
                        maxRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: 10
                    }
                },
                y: {
                    position: 'right',
                    grid: {
                        color: 'rgba(42, 54, 85, 0.3)',
                        drawBorder: false
                    },
                    ticks: {
                        color: '#8b9dc3',
                        callback: function(value) {
                            return value.toFixed(5);
                        }
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            },
            animation: {
                duration: 0
            }
        }
    });
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –Ω–∞ –≥—Ä–∞—Ñ–∏–∫
    addIndicatorsToChart();
}

function generateCandlestickData(count) {
    const asset = CONFIG.assets[currentAsset];
    const candles = [];
    const now = new Date();
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–≤–µ—á–∏
    for (let i = count - 1; i >= 0; i--) {
        const time = new Date(now);
        time.setMinutes(time.getMinutes() - i);
        
        let open, high, low, close;
        
        if (i === count - 1) {
            // –ü–µ—Ä–≤–∞—è —Å–≤–µ—á–∞
            open = asset.price;
            const change = (Math.random() - 0.5) * asset.volatility;
            close = open * (1 + change);
            high = Math.max(open, close) * (1 + Math.random() * asset.volatility * 0.3);
            low = Math.min(open, close) * (1 - Math.random() * asset.volatility * 0.3);
        } else {
            // –ü–æ—Å–ª–µ–¥—É—é—â–∏–µ —Å–≤–µ—á–∏
            const prevCandle = candles[candles.length - 1];
            open = prevCandle.c;
            const change = (Math.random() - 0.5) * asset.volatility;
            close = open * (1 + change);
            high = Math.max(open, close) * (1 + Math.random() * asset.volatility * 0.3);
            low = Math.min(open, close) * (1 - Math.random() * asset.volatility * 0.3);
            
            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º high/low
            high = Math.max(high, open, close);
            low = Math.min(low, open, close);
        }
        
        candles.push({
            x: time,
            o: open,
            h: high,
            l: low,
            c: close
        });
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é —Ü–µ–Ω
    priceHistory = candles.map(c => c.c);
    
    return { candles };
}

function addIndicatorsToChart() {
    if (!currentChart) return;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ª–∏–Ω–∏–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
    const datasets = currentChart.data.datasets;
    
    // EMA 20
    const ema20 = calculateEMA(priceHistory, 20);
    datasets.push({
        label: 'EMA 20',
        data: ema20.map((value, index) => ({
            x: currentChart.data.datasets[0].data[index].x,
            y: value
        })),
        borderColor: '#ffaa00',
        backgroundColor: 'transparent',
        borderWidth: 2,
        pointRadius: 0,
        fill: false
    });
    
    // EMA 50
    const ema50 = calculateEMA(priceHistory, 50);
    datasets.push({
        label: 'EMA 50',
        data: ema50.map((value, index) => ({
            x: currentChart.data.datasets[0].data[index].x,
            y: value
        })),
        borderColor: '#9d4edd',
        backgroundColor: 'transparent',
        borderWidth: 2,
        pointRadius: 0,
        fill: false
    });
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–∞—Ñ–∏–∫
    currentChart.update();
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
    indicatorsData = {
        ema20: ema20,
        ema50: ema50,
        rsi: calculateRSI(priceHistory),
        macd: calculateMACD(priceHistory)
    };
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
    updateIndicatorsDisplay();
}

// ==================== –ò–ù–î–ò–ö–ê–¢–û–†–´ ====================
function calculateEMA(prices, period) {
    const ema = [];
    const multiplier = 2 / (period + 1);
    
    // –ü–µ—Ä–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ EMA - –ø—Ä–æ—Å—Ç–æ–µ —Å—Ä–µ–¥–Ω–µ–µ
    let sum = 0;
    for (let i = 0; i < period && i < prices.length; i++) {
        sum += prices[i];
    }
    ema[period - 1] = sum / period;
    
    // –ü–æ—Å–ª–µ–¥—É—é—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è EMA
    for (let i = period; i < prices.length; i++) {
        ema[i] = (prices[i] - ema[i - 1]) * multiplier + ema[i - 1];
    }
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    for (let i = 0; i < period - 1; i++) {
        ema[i] = prices[i];
    }
    
    return ema;
}

function calculateRSI(prices, period = 14) {
    if (prices.length < period + 1) return Array(prices.length).fill(50);
    
    const gains = [];
    const losses = [];
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
    for (let i = 1; i < prices.length; i++) {
        const change = prices[i] - prices[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? -change : 0);
    }
    
    const rsi = [];
    
    // –ü–µ—Ä–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ RSI
    let avgGain = 0;
    let avgLoss = 0;
    
    for (let i = 0; i < period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
    }
    
    avgGain /= period;
    avgLoss /= period;
    
    let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
    rsi[period] = 100 - (100 / (1 + rs));
    
    // –°–ª–µ–¥—É—é—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è RSI
    for (let i = period + 1; i < prices.length; i++) {
        avgGain = ((avgGain * (period - 1)) + gains[i - 1]) / period;
        avgLoss = ((avgLoss * (period - 1)) + losses[i - 1]) / period;
        
        rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        rsi[i] = 100 - (100 / (1 + rs));
    }
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    for (let i = 0; i < period; i++) {
        rsi[i] = 50;
    }
    
    return rsi;
}

function calculateMACD(prices) {
    const ema12 = calculateEMA(prices, 12);
    const ema26 = calculateEMA(prices, 26);
    
    const macdLine = [];
    for (let i = 0; i < prices.length; i++) {
        macdLine.push(ema12[i] - ema26[i]);
    }
    
    const signalLine = calculateEMA(macdLine, 9);
    
    const histogram = [];
    for (let i = 0; i < prices.length; i++) {
        histogram.push(macdLine[i] - signalLine[i]);
    }
    
    return {
        macdLine,
        signalLine,
        histogram
    };
}

function updateIndicatorsDisplay() {
    const display = document.getElementById('indicators-display');
    if (!display) return;
    
    const dict = CONFIG.languages[currentLanguage];
    const lastIndex = priceHistory.length - 1;
    
    display.innerHTML = '';
    
    // RSI
    const rsiValue = indicatorsData.rsi[lastIndex];
    const rsiElement = createIndicatorElement('RSI', rsiValue.toFixed(2), 
        rsiValue > 70 ? 'negative' : rsiValue < 30 ? 'positive' : 'neutral');
    display.appendChild(rsiElement);
    
    // MACD
    const macdValue = indicatorsData.macd.macdLine[lastIndex];
    const macdElement = createIndicatorElement('MACD', macdValue.toFixed(5),
        macdValue > 0 ? 'positive' : 'negative');
    display.appendChild(macdElement);
    
    // EMA 20
    const ema20Value = indicatorsData.ema20[lastIndex];
    const ema20Element = createIndicatorElement('EMA20', ema20Value.toFixed(5),
        priceHistory[lastIndex] > ema20Value ? 'positive' : 'negative');
    display.appendChild(ema20Element);
    
    // EMA 50
    const ema50Value = indicatorsData.ema50[lastIndex];
    const ema50Element = createIndicatorElement('EMA50', ema50Value.toFixed(5),
        priceHistory[lastIndex] > ema50Value ? 'positive' : 'negative');
    display.appendChild(ema50Element);
    
    // –¢—Ä–µ–Ω–¥
    const trend = determineTrend();
    const trendElement = createIndicatorElement(dict.trend, trend.direction,
        trend.strength > 0 ? 'positive' : 'negative');
    display.appendChild(trendElement);
}

function createIndicatorElement(label, value, type) {
    const div = document.createElement('div');
    div.className = 'indicator-item';
    
    const color = type === 'positive' ? '#00ff88' : 
                  type === 'negative' ? '#ff4444' : '#8b9dc3';
    
    div.innerHTML = `
        <span>${label}:</span>
        <span class="indicator-value" style="color: ${color}">${value}</span>
    `;
    
    return div;
}

function determineTrend() {
    const prices = priceHistory;
    if (prices.length < 20) return { direction: '–ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π', strength: 0 };
    
    const lastPrice = prices[prices.length - 1];
    const ema20 = indicatorsData.ema20[prices.length - 1];
    const ema50 = indicatorsData.ema50[prices.length - 1];
    
    let direction = '–ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π';
    let strength = 0;
    
    if (lastPrice > ema20 && ema20 > ema50) {
        direction = '–ë—ã—á–∏–π ‚Üó';
        strength = 1;
    } else if (lastPrice < ema20 && ema20 < ema50) {
        direction = '–ú–µ–¥–≤–µ–∂–∏–π ‚Üò';
        strength = -1;
    }
    
    return { direction, strength };
}

// ==================== –ò–ù–°–¢–†–£–ú–ï–ù–¢–´ –†–ò–°–û–í–ê–ù–ò–Ø ====================
function initDrawingTools() {
    const drawButtons = document.querySelectorAll('.draw-btn');
    
    drawButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const tool = this.dataset.tool;
            
            // –°–Ω–∏–º–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –∫–ª–∞—Å—Å —Å–æ –≤—Å–µ—Ö –∫–Ω–æ–ø–æ–∫
            drawButtons.forEach(b => b.classList.remove('active'));
            
            if (tool === 'clear') {
                clearDrawings();
                drawingMode = null;
            } else {
                this.classList.add('active');
                drawingMode = tool;
                alert(`–†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è: ${tool}. –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç.`);
            }
        });
    });
    
    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫
    const chartCanvas = document.getElementById('trading-chart');
    if (chartCanvas) {
        chartCanvas.addEventListener('click', function(event) {
            if (drawingMode) {
                addDrawingElement(event);
            }
        });
    }
}

function addDrawingElement(event) {
    if (!drawingMode || !currentChart) return;
    
    const rect = event.target.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    const scales = currentChart.scales;
    const xValue = scales.x.getValueForPixel(x);
    const yValue = scales.y.getValueForPixel(y);
    
    const element = {
        type: drawingMode,
        x: xValue,
        y: yValue,
        timestamp: new Date()
    };
    
    drawnElements.push(element);
    drawOnChart(element);
}

function drawOnChart(element) {
    if (!currentChart) return;
    
    const ctx = currentChart.ctx;
    const scales = currentChart.scales;
    const xPixel = scales.x.getPixelForValue(element.x);
    const yPixel = scales.y.getPixelForValue(element.y);
    
    ctx.save();
    
    switch(element.type) {
        case 'line':
            // –†–∏—Å—É–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é
            ctx.beginPath();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#0066ff';
            ctx.lineWidth = 2;
            ctx.moveTo(scales.x.left, yPixel);
            ctx.lineTo(scales.x.right, yPixel);
            ctx.stroke();
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç
            ctx.fillStyle = '#0066ff';
            ctx.font = '12px Arial';
            ctx.fillText(element.y.toFixed(5), scales.x.right - 60, yPixel - 5);
            break;
            
        case 'horizontal':
            // –†–∏—Å—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 1;
            ctx.moveTo(xPixel, scales.y.top);
            ctx.lineTo(xPixel, scales.y.bottom);
            ctx.stroke();
            break;
            
        case 'fibonacci':
            // –†–∏—Å—É–µ–º —É—Ä–æ–≤–µ–Ω—å –§–∏–±–æ–Ω–∞—á—á–∏
            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = '#9d4edd';
            ctx.lineWidth = 1;
            ctx.moveTo(scales.x.left, yPixel);
            ctx.lineTo(scales.x.right, yPixel);
            ctx.stroke();
            
            ctx.fillStyle = '#9d4edd';
            ctx.font = '11px Arial';
            ctx.fillText('Fib: ' + element.y.toFixed(5), scales.x.right - 80, yPixel - 5);
            break;
    }
    
    ctx.restore();
}

function clearDrawings() {
    drawnElements = [];
    if (currentChart) {
        currentChart.update();
    }
}

// ==================== –°–û–ë–´–¢–ò–Ø ====================
function initEvents() {
    // –í—ã–±–æ—Ä –∞–∫—Ç–∏–≤–∞
    const assetSelect = document.getElementById('asset-select');
    if (assetSelect) {
        assetSelect.addEventListener('change', function() {
            currentAsset = this.value;
            updateAssetDisplay();
            reloadChart();
        });
    }
    
    // –ö–Ω–æ–ø–∫–∏ —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤
    document.querySelectorAll('.time-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentTimeframe = parseInt(this.dataset.time);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            const tfText = CONFIG.timeframes[currentTimeframe];
            document.getElementById('current-tf').textContent = tfText;
        });
    });
    
    // –¢–∏–ø—ã —Å–∏–≥–Ω–∞–ª–æ–≤
    document.querySelectorAll('.signal-type-option').forEach(option => {
        option.addEventListener('click', function() {
            document.querySelectorAll('.signal-type-option').forEach(o => o.classList.remove('active'));
            this.classList.add('active');
            signalType = this.dataset.type;
        });
    });
    
    // –¢–∏–ø—ã –≥—Ä–∞—Ñ–∏–∫–æ–≤
    document.querySelectorAll('.chart-type-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.chart-type-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            chartType = this.dataset.type;
            changeChartType(chartType);
        });
    });
    
    // –ö–Ω–æ–ø–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞
    const generateBtn = document.getElementById('generate-signal');
    if (generateBtn) {
        generateBtn.addEventListener('click', generateSignal);
    }
}

function changeChartType(type) {
    if (!currentChart) return;
    
    currentChart.config.type = type === 'candlestick' ? 'candlestick' : 'line';
    
    if (type === 'line') {
        currentChart.data.datasets[0].type = 'line';
        currentChart.data.datasets[0].borderColor = '#00ff88';
        currentChart.data.datasets[0].backgroundColor = 'rgba(0, 255, 136, 0.1)';
        currentChart.data.datasets[0].fill = true;
    } else if (type === 'area') {
        currentChart.data.datasets[0].type = 'line';
        currentChart.data.datasets[0].borderColor = '#0066ff';
        currentChart.data.datasets[0].backgroundColor = 'rgba(0, 102, 255, 0.1)';
        currentChart.data.datasets[0].fill = true;
    } else {
        currentChart.data.datasets[0].type = 'candlestick';
    }
    
    currentChart.update();
}

// ==================== –¶–ï–ù–´ ====================
async function loadInitialPrices() {
    try {
        await fetchRealPrices();
    } catch (error) {
        useDemoPrices();
    }
    updateAssetDisplay();
}

async function fetchRealPrices() {
    try {
        const response = await fetch('https://api.frankfurter.app/latest?from=USD');
        if (!response.ok) throw new Error('API error');
        
        const data = await response.json();
        
        if (data.rates) {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–Ω—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            CONFIG.assets.EURUSD.price = 1 / data.rates.EUR || 1.0830;
            CONFIG.assets.USDJPY.price = data.rates.JPY || 148.35;
            CONFIG.assets.GBPUSD.price = 1 / data.rates.GBP || 1.2650;
            CONFIG.assets.AUDUSD.price = 1 / data.rates.AUD || 0.6590;
            CONFIG.assets.USDCAD.price = data.rates.CAD || 1.3520;
            CONFIG.assets.USDCHF.price = data.rates.CHF || 0.9025;
            
            // –†–∞—Å—á–µ—Ç–Ω—ã–µ –ø–∞—Ä—ã
            CONFIG.assets.EURJPY.price = CONFIG.assets.EURUSD.price * CONFIG.assets.USDJPY.price;
            CONFIG.assets.GBPJPY.price = CONFIG.assets.GBPUSD.price * CONFIG.assets.USDJPY.price;
            
            return true;
        }
    } catch (error) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã:', error);
        throw error;
    }
}

function useDemoPrices() {
    Object.keys(CONFIG.assets).forEach(asset => {
        const change = (Math.random() - 0.5) * CONFIG.assets[asset].volatility;
        CONFIG.assets[asset].price *= (1 + change);
    });
}

function startPriceUpdates() {
    priceUpdateInterval = setInterval(async () => {
        try {
            await fetchRealPrices();
        } catch (error) {
            useDemoPrices();
        }
        updateAssetDisplay();
        updateChartData();
    }, 5000);
}

function updateAssetDisplay() {
    const asset = CONFIG.assets[currentAsset];
    if (!asset) return;
    
    const priceElement = document.getElementById('current-price');
    const pairElement = document.getElementById('current-pair');
    const changeElement = document.getElementById('price-change');
    const priceDisplay = document.getElementById('current-price-display');
    const changeDisplay = document.getElementById('price-change-display');
    
    if (priceElement) priceElement.textContent = asset.price.toFixed(5);
    if (pairElement) pairElement.textContent = asset.name;
    if (priceDisplay) priceDisplay.textContent = asset.price.toFixed(5);
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
    const changePercent = (Math.random() - 0.5) * 0.1;
    if (changeElement) {
        changeElement.textContent = `${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%`;
        changeElement.className = changePercent >= 0 ? 'positive' : 'negative';
    }
    if (changeDisplay) {
        changeDisplay.textContent = `${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%`;
        changeDisplay.className = changePercent >= 0 ? 'positive' : 'negative';
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
    document.getElementById('chart-time').textContent = 
        `–û–±–Ω–æ–≤–ª–µ–Ω–æ: ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})} UTC`;
}

function updateChartData() {
    if (!currentChart) return;
    
    const asset = CONFIG.assets[currentAsset];
    const lastCandle = currentChart.data.datasets[0].data[currentChart.data.datasets[0].data.length - 1];
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–≤–µ—á—É
    const newTime = new Date();
    const change = (Math.random() - 0.5) * asset.volatility;
    
    const newCandle = {
        x: newTime,
        o: lastCandle.c,
        h: Math.max(lastCandle.c, asset.price) * (1 + Math.random() * asset.volatility * 0.2),
        l: Math.min(lastCandle.c, asset.price) * (1 - Math.random() * asset.volatility * 0.2),
        c: asset.price
    };
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Å–≤–µ—á—É –∏ —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é
    currentChart.data.datasets[0].data.push(newCandle);
    currentChart.data.datasets[0].data.shift();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    updateIndicators();
    
    currentChart.update('none');
}

function updateIndicators() {
    const prices = currentChart.data.datasets[0].data.map(d => d.c);
    priceHistory = prices;
    
    // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    indicatorsData.ema20 = calculateEMA(prices, 20);
    indicatorsData.ema50 = calculateEMA(prices, 50);
    indicatorsData.rsi = calculateRSI(prices);
    indicatorsData.macd = calculateMACD(prices);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ª–∏–Ω–∏–∏ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ
    updateIndicatorLines();
    updateIndicatorsDisplay();
}

function updateIndicatorLines() {
    if (!currentChart || currentChart.data.datasets.length < 3) return;
    
    const prices = currentChart.data.datasets[0].data;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º EMA 20
    currentChart.data.datasets[1].data = indicatorsData.ema20.map((value, index) => ({
        x: prices[index].x,
        y: value
    }));
    
    // –û–±–Ω–æ–≤–ª—è–µ–º EMA 50
    currentChart.data.datasets[2].data = indicatorsData.ema50.map((value, index) => ({
        x: prices[index].x,
        y: value
    }));
}

function reloadChart() {
    if (currentChart) {
        currentChart.destroy();
    }
    initChart();
    updateIndicatorsDisplay();
}

// ==================== –°–ò–ì–ù–ê–õ–´ ====================
async function generateSignal() {
    if (isSignalActive) {
        alert(currentLanguage === 'ru' ? '–î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ —Å–∏–≥–Ω–∞–ª–∞' : 'Wait for current signal to complete');
        return;
    }
    
    isSignalActive = true;
    
    // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É
    const btn = document.getElementById('generate-signal');
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ' + 
                   (currentLanguage === 'ru' ? '–ê–ù–ê–õ–ò–ó...' : 'ANALYZING...');
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∞–Ω–∞–ª–∏–∑–∞
    updateSignalStatus(currentLanguage === 'ru' ? '–ê–Ω–∞–ª–∏–∑...' : 'Analyzing...', '#ffaa00');
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
    showAnalysisAnimation();
    
    // –ê–Ω–∞–ª–∏–∑ (2-3 —Å–µ–∫—É–Ω–¥—ã)
    setTimeout(() => {
        createSignal();
    }, 2000 + Math.random() * 1000);
}

function showAnalysisAnimation() {
    const signalContent = document.getElementById('signal-content');
    if (signalContent) {
        const dict = CONFIG.languages[currentLanguage];
        signalContent.innerHTML = `
            <div style="text-align: center;">
                <div style="display: inline-block; width: 60px; height: 60px; border: 3px solid #2a3655; 
                          border-top-color: #00ff88; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <p style="margin-top: 15px; color: #8b9dc3; font-size: 14px;">
                    <i class="fas fa-chart-line"></i><br>
                    ${dict.analysis}...
                </p>
                <div style="margin-top: 10px; font-size: 12px; color: #5d6d97;">
                    ${signalType === 'smart' ? 'Smart Money Concepts' : 
                      signalType === 'indicators' ? 'Technical Indicators' : 'Combined Analysis'}
                </div>
            </div>
        `;
    }
}

function createSignal() {
    const asset = CONFIG.assets[currentAsset];
    const dict = CONFIG.languages[currentLanguage];
    
    // –ê–Ω–∞–ª–∏–∑ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞
    const analysis = performAdvancedAnalysis();
    
    // –°–æ–∑–¥–∞–µ–º —Å–∏–≥–Ω–∞–ª
    currentSignal = {
        asset: currentAsset,
        pair: asset.name,
        direction: analysis.direction,
        entryPrice: asset.price,
        confidence: analysis.confidence,
        indicators: analysis.indicators,
        timestamp: new Date(),
        type: signalType,
        result: null
    };
    
    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–∏–≥–Ω–∞–ª
    displaySignal();
    
    // –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É
    const btn = document.getElementById('generate-signal');
    btn.disabled = false;
    btn.innerHTML = '<i class="fas fa-bolt"></i> ' + dict.getSignal;
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
    startExpirationTimer();
}

function performAdvancedAnalysis() {
    const prices = priceHistory;
    const lastPrice = prices[prices.length - 1];
    
    // –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç –≤—Å–µ—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
    const indicators = {
        rsi: indicatorsData.rsi[prices.length - 1],
        macd: indicatorsData.macd.macdLine[prices.length - 1],
        macdHistogram: indicatorsData.macd.histogram[prices.length - 1],
        ema20: indicatorsData.ema20[prices.length - 1],
        ema50: indicatorsData.ema50[prices.length - 1],
        trend: determineTrend()
    };
    
    let direction = 'BUY';
    let confidence = 75;
    let confirmations = [];
    
    // –ê–Ω–∞–ª–∏–∑ RSI
    if (indicators.rsi < 30) {
        confirmations.push('RSI oversold');
        confidence += 5;
    } else if (indicators.rsi > 70) {
        confirmations.push('RSI overbought');
        confidence -= 5;
    }
    
    // –ê–Ω–∞–ª–∏–∑ MACD
    if (indicators.macd > 0 && indicators.macdHistogram > 0) {
        confirmations.push('MACD bullish');
        confidence += 8;
    } else if (indicators.macd < 0 && indicators.macdHistogram < 0) {
        confirmations.push('MACD bearish');
        confidence -= 8;
    }
    
    // –ê–Ω–∞–ª–∏–∑ EMA
    if (lastPrice > indicators.ema20 && indicators.ema20 > indicators.ema50) {
        confirmations.push('EMA bullish alignment');
        confidence += 10;
        direction = 'BUY';
    } else if (lastPrice < indicators.ema20 && indicators.ema20 < indicators.ema50) {
        confirmations.push('EMA bearish alignment');
        confidence += 10;
        direction = 'SELL';
    }
    
    // Smart Money –∞–Ω–∞–ª–∏–∑ (–µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω)
    if (signalType === 'smart' || signalType === 'combined') {
        const smartAnalysis = analyzeSmartMoney();
        confirmations = confirmations.concat(smartAnalysis.confirmations);
        confidence += smartAnalysis.confidenceBoost;
        
        if (smartAnalysis.direction) {
            direction = smartAnalysis.direction;
        }
    }
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
    confidence = Math.max(60, Math.min(95, Math.round(confidence)));
    
    return {
        direction,
        confidence,
        indicators,
        confirmations
    };
}

function analyzeSmartMoney() {
    const confirmations = [];
    let confidenceBoost = 0;
    let direction = null;
    
    // –ò–º–∏—Ç–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ Smart Money
    const randomFactor = Math.random();
    
    if (randomFactor > 0.6) {
        confirmations.push('Liquidity sweep detected');
        confirmations.push('Order block formed');
        confidenceBoost += 15;
        direction = randomFactor > 0.8 ? 'BUY' : 'SELL';
    } else if (randomFactor > 0.3) {
        confirmations.push('Fair value gap');
        confidenceBoost += 8;
    }
    
    return { confirmations, confidenceBoost, direction };
}

function displaySignal() {
    const signal = currentSignal;
    const dict = CONFIG.languages[currentLanguage];
    
    // –°–∫—Ä—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏
    document.getElementById('signal-content').style.display = 'none';
    document.getElementById('signal-details').style.display = 'block';
    document.getElementById('signal-analysis').style.display = 'block';
    document.getElementById('expiration-timer').style.display = 'block';
    
    // –î–µ—Ç–∞–ª–∏ —Å–∏–≥–Ω–∞–ª–∞
    const detailsHTML = `
        <div style="padding: 20px;">
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
                <div>
                    <div style="font-size: 11px; color: #8b9dc3; margin-bottom: 5px;">${dict.instrument}</div>
                    <div style="font-size: 18px; font-weight: 700;">${signal.pair}</div>
                </div>
                <div>
                    <div style="font-size: 11px; color: #8b9dc3; margin-bottom: 5px;">${dict.entryPrice}</div>
                    <div style="font-size: 18px; font-weight: 700; font-family: 'Courier New', monospace;">${signal.entryPrice.toFixed(5)}</div>
                </div>
            </div>
            
            <div style="text-align: center; margin: 20px 0;">
                <div style="font-size: 32px; font-weight: 800; color: ${signal.direction === 'BUY' ? '#00ff88' : '#ff4444'}; 
                          text-transform: uppercase; margin-bottom: 5px;">
                    ${signal.direction === 'BUY' ? dict.buy : dict.sell}
                </div>
                <div style="font-size: 24px; font-weight: 700; color: #00ff88;">
                    ${signal.confidence}%
                </div>
                <div style="font-size: 12px; color: #8b9dc3; margin-top: 5px;">
                    ${signal.type === 'smart' ? 'Smart Money' : 
                      signal.type === 'indicators' ? 'Technical Indicators' : 'Combined Analysis'}
                </div>
            </div>
            
            <div style="font-size: 11px; color: #5d6d97; text-align: center;">
                <i class="far fa-clock"></i>
                ${signal.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})}
            </div>
        </div>
    `;
    
    document.getElementById('signal-details').innerHTML = detailsHTML;
    
    // –ê–Ω–∞–ª–∏–∑ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
    const analysisHTML = `
        <div style="padding: 15px;">
            <div style="font-size: 11px; color: #8b9dc3; margin-bottom: 10px; text-transform: uppercase;">
                <i class="fas fa-chart-bar"></i> ${dict.analysis}
            </div>
            <div class="analysis-grid">
                <div class="analysis-item">
                    <div class="analysis-label">${dict.rsi}</div>
                    <div class="analysis-value ${signal.indicators.rsi > 70 ? 'negative' : signal.indicators.rsi < 30 ? 'positive' : ''}">
                        ${signal.indicators.rsi.toFixed(1)}
                    </div>
                </div>
                <div class="analysis-item">
                    <div class="analysis-label">${dict.macd}</div>
                    <div class="analysis-value ${signal.indicators.macd > 0 ? 'positive' : 'negative'}">
                        ${signal.indicators.macd.toFixed(5)}
                    </div>
                </div>
                <div class="analysis-item">
                    <div class="analysis-label">${dict.ema} 20</div>
                    <div class="analysis-value ${signal.entryPrice > signal.indicators.ema20 ? 'positive' : 'negative'}">
                        ${signal.indicators.ema20.toFixed(5)}
                    </div>
                </div>
                <div class="analysis-item">
                    <div class="analysis-label">${dict.trend}</div>
                    <div class="analysis-value ${signal.indicators.trend.strength > 0 ? 'positive' : signal.indicators.trend.strength < 0 ? 'negative' : ''}">
                        ${signal.indicators.trend.direction}
                    </div>
                </div>
                <div class="analysis-item">
                    <div class="analysis-label">${dict.strength}</div>
                    <div class="analysis-value positive">
                        ${signal.confirmations.length}/5
                    </div>
                </div>
                <div class="analysis-item">
                    <div class="analysis-label">${dict.volume}</div>
                    <div class="analysis-value ${Math.random() > 0.5 ? 'positive' : 'negative'}">
                        ${(Math.random() * 100).toFixed(0)}%
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.getElementById('signal-analysis').innerHTML = analysisHTML;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
    updateSignalStatus('ACTIVE', signal.direction === 'BUY' ? '#00ff88' : '#ff4444');
}

function updateSignalStatus(text, color) {
    const statusElement = document.getElementById('signal-status');
    const statusText = document.getElementById('status-text');
    
    if (statusElement && statusText) {
        const dot = statusElement.querySelector('.status-dot');
        if (dot) {
            dot.style.background = color;
            dot.style.boxShadow = `0 0 10px ${color}`;
        }
        statusText.textContent = text;
        statusText.style.color = color;
    }
}

function startExpirationTimer() {
    const totalTime = currentTimeframe;
    let timeLeft = totalTime;
    
    const timerBar = document.getElementById('timer-bar');
    const timerValue = document.getElementById('timer-value');
    
    if (!timerBar || !timerValue) return;
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
    timerBar.style.transition = 'none';
    timerBar.style.transform = 'scaleX(1)';
    void timerBar.offsetWidth;
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
    timerBar.style.transition = `transform ${totalTime}s linear`;
    timerBar.style.transform = 'scaleX(0)';
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
    expirationTimer = setInterval(() => {
        timeLeft--;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerValue.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // –ú–µ–Ω—è–µ–º —Ü–≤–µ—Ç
        const progress = timeLeft / totalTime;
        if (progress < 0.3) {
            timerBar.style.background = 'linear-gradient(90deg, #ff4444, #ffaa00)';
        } else if (progress < 0.7) {
            timerBar.style.background = 'linear-gradient(90deg, #ffaa00, #00ff88)';
        }
        
        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ
        if (timeLeft <= 0) {
            clearInterval(expirationTimer);
            finishSignal();
        }
    }, 1000);
}

function finishSignal() {
    if (!currentSignal) return;
    
    const dict = CONFIG.languages[currentLanguage];
    const currentPrice = CONFIG.assets[currentAsset].price;
    const entryPrice = currentSignal.entryPrice;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    let result, resultColor, resultText;
    
    if (currentSignal.direction === 'BUY') {
        if (currentPrice > entryPrice * 1.0001) {
            result = 'WIN';
            resultColor = '#00ff88';
            resultText = dict.win;
        } else if (currentPrice < entryPrice * 0.9999) {
            result = 'LOSS';
            resultColor = '#ff4444';
            resultText = dict.loss;
        } else {
            result = 'REFUND';
            resultColor = '#8b9dc3';
            resultText = dict.refund;
        }
    } else {
        if (currentPrice < entryPrice * 0.9999) {
            result = 'WIN';
            resultColor = '#00ff88';
            resultText = dict.win;
        } else if (currentPrice > entryPrice * 1.0001) {
            result = 'LOSS';
            resultColor = '#ff4444';
            resultText = dict.loss;
        } else {
            result = 'REFUND';
            resultColor = '#8b9dc3';
            resultText = dict.refund;
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª
    currentSignal.result = result;
    currentSignal.exitPrice = currentPrice;
    currentSignal.completedAt = new Date();
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    showSignalResult(result, resultText, resultColor, currentPrice);
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
    addToHistory();
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥
    setTimeout(resetSignal, 5000);
}

function showSignalResult(result, resultText, resultColor, exitPrice) {
    const dict = CONFIG.languages[currentLanguage];
    const resultHTML = `
        <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid ${resultColor}30;">
            <div style="text-align: center;">
                <div style="font-size: 28px; font-weight: 800; color: ${resultColor}; margin-bottom: 5px;">
                    ${resultText}
                </div>
                <div style="font-size: 14px; color: #8b9dc3; margin-bottom: 15px;">
                    ${dict.result}
                </div>
                
                <div style="display: flex; justify-content: center; gap: 30px; margin-bottom: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 11px; color: #5d6d97;">${dict.entryPrice}</div>
                        <div style="font-size: 16px; font-weight: 700;">${currentSignal.entryPrice.toFixed(5)}</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 11px; color: #5d6d97;">${dict.exitPrice}</div>
                        <div style="font-size: 16px; font-weight: 700;">${exitPrice.toFixed(5)}</div>
                    </div>
                </div>
                
                <div style="font-size: 12px; color: #5d6d97;">
                    <i class="far fa-clock"></i>
                    ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})}
                </div>
            </div>
        </div>
    `;
    
    const detailsElement = document.getElementById('signal-details');
    if (detailsElement) {
        detailsElement.innerHTML += resultHTML;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
    updateSignalStatus(resultText, resultColor);
}

function addToHistory() {
    const resultsList = document.getElementById('results-list');
    if (!resultsList) return;
    
    const dict = CONFIG.languages[currentLanguage];
    const resultColor = currentSignal.result === 'WIN' ? '#00ff88' : 
                       currentSignal.result === 'LOSS' ? '#ff4444' : '#8b9dc3';
    
    const historyItem = document.createElement('div');
    historyItem.className = `result-item ${currentSignal.result.toLowerCase()} fade-in`;
    
    historyItem.innerHTML = `
        <div class="result-info">
            <span class="result-pair">${currentSignal.pair}</span>
            <span class="result-direction ${currentSignal.direction.toLowerCase()}">
                ${currentSignal.direction === 'BUY' ? '‚Üë' : '‚Üì'}
            </span>
            <span class="result-accuracy">${currentSignal.confidence}%</span>
        </div>
        <div style="text-align: right;">
            <div class="result-price">${currentSignal.entryPrice.toFixed(5)} ‚Üí ${currentSignal.exitPrice.toFixed(5)}</div>
            <div class="result-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
        </div>
    `;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ
    resultsList.insertBefore(historyItem, resultsList.firstChild);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
    saveHistory();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–æ—á–Ω–æ—Å—Ç–∏
    updateAccuracyStats();
}

function updateAccuracyStats() {
    const results = document.querySelectorAll('.result-item');
    const total = results.length;
    const wins = Array.from(results).filter(r => r.classList.contains('win')).length;
    
    if (total > 0) {
        const accuracy = ((wins / total) * 100).toFixed(1);
        document.getElementById('accuracy-rate').textContent = `${accuracy}%`;
    }
}

function saveHistory() {
    try {
        const history = {
            signal: currentSignal,
            timestamp: new Date().toISOString()
        };
        
        let savedHistory = JSON.parse(localStorage.getItem('tradingHistory') || '[]');
        savedHistory.unshift(history);
        
        if (savedHistory.length > 20) {
            savedHistory = savedHistory.slice(0, 20);
        }
        
        localStorage.setItem('tradingHistory', JSON.stringify(savedHistory));
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏:', error);
    }
}

function loadHistory() {
    try {
        const savedHistory = JSON.parse(localStorage.getItem('tradingHistory') || '[]');
        
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–≥—Ä—É–∑–∫—É –∏—Å—Ç–æ—Ä–∏–∏ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        if (savedHistory.length > 0) {
            console.log(`–ó–∞–≥—Ä—É–∂–µ–Ω–æ ${savedHistory.length} –∑–∞–ø–∏—Å–µ–π –∏—Å—Ç–æ—Ä–∏–∏`);
        }
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏:', error);
    }
}

function resetSignal() {
    isSignalActive = false;
    currentSignal = null;
    
    const dict = CONFIG.languages[currentLanguage];
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    document.getElementById('signal-content').style.display = 'flex';
    document.getElementById('signal-details').style.display = 'none';
    document.getElementById('signal-analysis').style.display = 'none';
    document.getElementById('expiration-timer').style.display = 'none';
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç
    const signalContent = document.getElementById('signal-content');
    if (signalContent) {
        signalContent.innerHTML = `
            <div class="signal-placeholder">
                <i class="fas fa-chart-line"></i>
                <p>${dict.clickGenerate}</p>
            </div>
        `;
    }
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å
    updateSignalStatus(dict.waiting, '#00ff88');
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä
    const timerBar = document.getElementById('timer-bar');
    const timerValue = document.getElementById('timer-value');
    if (timerBar && timerValue) {
        timerBar.style.transition = 'none';
        timerBar.style.transform = 'scaleX(1)';
        timerBar.style.background = 'linear-gradient(90deg, #00ff88, #0066ff)';
        timerValue.textContent = CONFIG.timeframes[currentTimeframe];
    }
    
    // –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª
    if (expirationTimer) {
        clearInterval(expirationTimer);
        expirationTimer = null;
    }
}
